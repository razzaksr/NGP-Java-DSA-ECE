https://github.com/razzaksr/NGP-Java-DSA-ECE

Sorting algorithms:
Insertion
Merge
Selection
Quick

Searching algorithms:
Linear 
Ternary
Binary




Assessment:
1. Write a method to calculate delivery charges based on distance. Overload it for weight-based charges too

2. Write a method to calculate monthly emi based on principleAmount, roi for 3 years. Overload it for Collateral to reduce roi

3. Write a program to find second maximum in unsorted array of product prices.

4. Write a program to find and print account balances those are not maintaining minimum balance threshold from unsorted array of customer balances


5. Banking:
Account (abstract class) contains accountNumber, accountBalance with subclasses SavingsAccount and CurrentAccount.
Interface Transaction with deposit() and withdraw().
Savings Account:
withdraw >> no charges upto 50000, 3% for more than 50000
CurrentAccount:
withdraw>> charges for each 10000 of 2.5%


Discussed Setter and Getter


Storage Structures: Linear
	Array
	Stack >> LIFO
		push, pop, peek, isEmpty, viewAll
	Implementation:
		In built: java.util.Stack
		Manual Implementation:
			1. fixed memory using array
			2. dynamic memory using object oriented/ linkedlist

Collection Framework
Iterable>> Collection>> AbstractCollection>> Vector>> Stack

Validate Expression with Brackets, Parenthesis


Largest rectangle are in histogram

1, 3, 5,4,2              max=Integer.MIN_VALUE
0  1  2 3 4

index=0, arr[index] = 1>> current
push 0
Stack>> for index          
0 


Daily Temperature 
Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.
Example 1:
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
Example 2:
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]



Queue >> FiFo
	enqueue, dequeue, isEmpty, front, rear
	
	Implementation:
	1. fixed memory via stack
	2. inbuilt class>> Queue>> java.util
	3. LinkedList/ Object oriented


	Queue>>
		offer(enqueue), poll(dequeue), empty
		PriorityQueue>> Deque
			remove small element always
			if we wish removal in different way we can configure
		



Collection framework: 
to overcome array drawbacks
	List>> ArrayList, LinkedList

LinkedList >> 
	add / addLast, addaddFirst, add(pos,object)

	get(pos), getFirst, getLast

	remove / removeFirst, removeLast, remove(position)

ArrayList:
	add, add(pos,obj), addAll
	set(pos,obj)
	contains(obj)// true/false
	remove(obj)
	get(pos)





---






Command Prompt:
java   -version



environment path settings:

vs code java extension:
EXTENSION PACK FOR JAVA


FD Calculator:
oneYear  = pA * roi/100 >> single year interest

oneYear * duration


Versions of solution:
without OOP
encapsulation
polymorphsim



inheritance
overriding
upcast, downcast


Abstraction:
	Interface
	Abstract class
	Overriding
	
User defined Class as generic to Collections


Comparator interface>> 
bean class and interface implementation can be separate
	compare(Object o1,Object o2)>> override

Queue with problem solving:
	rotation
	palindrome


Comparable interface>> 
implementation has to be done in bean class itself
	compareTo(Object o) >> override


Set : 
	LinkedHashSet, HashSet, TreeSet
	TreeSet with User Defined Type
	Comparable implementation


Map: <K, V>:
Key Objects Should not be duplicated, Value Objects can be
insert>> put(k,v), putAll
read>> get(K)
check>>containsKey(K) , containsValue(V)
read only keys>> keySet()>> convert K Objects into new Set
read only values> values() >> convert V Objects into Collection
delete >> remove(K)

	HashMap/ Hashtable
	TreeMap


1. Count Occurrences of String
2. Find Distinct digits
3. Agile Kanban Board implemented via Map
4. Undirected Graph representation using Map
	

















Single Number
Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.
Example 1:
Input: nums = [2,2,1]
Output: 1

Example 2:
Input: nums = [4,1,2,1,2]
Output: 4

Example 3:
Input: nums = [1]
Output: 1



Counting Bits:
Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.

Example 1:
Input: n = 2
Output: [0,1,1]
Explanation:0 --> 0   1 --> 1         2 --> 10

Example 2:
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101


Find the least prime number within the boundary that can be added with first array element that makes them divisible by second array elements at respective index
		Input:
		int[] arr1 = {3, 5, 7};
		int[] arr2 = {10, 15, 20};
		Output:
		7 -1 13 
		Input:
		int[] arr1 = {4, 6, 8};
		int[] arr2 = {5, 10, 15};
		Output:
		-1 -1 -1

1. Move Zeroes
Problem Statement:
Rearrange a delivery queue where zeros indicate unavailable trucks; push them to the end without disrupting the rest.
	Sample Input:
	nums = [0, 1, 0, 3, 12]
	Expected Output:
	[1, 3, 12, 0, 0]

	Input:
	20,0,19,5,0,3,10,0,2
	Output:
	20,19,5,3,10,2,0,0,0

	Input:
	3,0,0,1,0,5,0,6,0
	Output:
	3,1,5,6,0,0,0,0,0




Rotate Image
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]














Rotating clock wise and anti clock wise
example:
arr = [DBMS, OS, DSA, Network, AI]
n = 2
Clock Wise: 
[Network, AI, DBMS, OS, DSA]
Anti Clock Wise: 
[DSA, Network, AI, DBMS, OS]


Find Pivot Index
Problem Statement:
Determine the index at which the workload to its left equals the workload to its right.
	Sample Input:
	nums = [1, 7, 3, 6, 5, 6]
	Expected Output:	3
	Explanation: 1 + 7 + 3 = 11, 5 + 6 = 11.
	Input:
	-7, 1, 5, 2, -4, 3, 0
	Output:	3
	Input:
	0,-3,5,-4,-2,3,1,0
	Output:	0


Group Anagrams
		Problem Statement:
		Cluster search queries or user aliases that are scrambled versions of each other â€” useful in NLP or 		search optimization.
		Sample Input:
		strs = ["eat","tea","tan","ate","nat","bat"]
		Expected Output:
		[["eat","tea","ate"], ["tan","nat"], ["bat"]]



Minimum Moves to Convert String
You are given a string s consisting of n characters which are either 'X' or 'O'.
A move is defined as selecting three consecutive characters of s and converting them to 'O'. Note that if a move is applied to the character 'O', it will stay the same.
Return the minimum number of moves required so that all the characters of s are converted to 'O'.
		Example 1:
		Input: s = "XXX"
		Output: 1	
		Explanation: XXX -> OOO
		We select all the 3 characters and convert them in one move.
		Example 2:
		Input: s = "XXOX"
		Output: 2
		Explanation: XXOX -> OOOX -> OOOO
We select the first 3 characters in the first move, and convert them to 'O'.
Then we select the last 3 characters and convert them so that the final string contains all 'O's.
		Example 3:
		Input: s = "OOOO"
		Output: 0
Explanation: There are no 'X's in s to convert.










Validating IPV4
Input: s = "222.111.111.111"
Output: true
Explanation: Here, the IPv4 address is as per the criteria mentioned and also all four decimal numbers lies in the mentioned range.
Input: s = "5555..555"
Output: false
Explanation: "5555..555" is not a valid. IPv4 address, as the middle two portions are missing.
Input: s = "0.0.0.0255"
Output: false
Input: 121.433.122.111
Output: false
Input: 192.168.137.12
Output: true
Input: 22.0..123
Output: false
Input: 1.2.3.4.
Output: false
Input: .1.2.3.4
Output: false



Debt Offset Triplets
In financial reconciliation systems or crowdfunding platforms, contributions from individuals may either be positive (contributions) or negative (debts). When evaluating such data, it becomes important to identify sets of contributors whose combined impact on the overall balance nets to zero.
You are given a list of integers nums, where each value represents the contribution or debt of a participant. Your task is to find all unique triplets in the list which sum to zero.
Each triplet must include three distinct elements from the array, and the result must not contain duplicate triplets, regardless of the order. For example, triplets like [-1, 0, 1] and [0, 1, -1] are considered the same and should be reported only once.
This problem simulates scenarios such as offsetting financial imbalances, detecting fraudulent balancing acts, or automated clearing systems identifying neutralizing transactions.
Example 1:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Example 2:
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
Example 3:
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.





Trapping Rain Water
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water are being trapped.

Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9




Best Time to Buy and Sell Stock
Problem Statement:
Identify the best day to buy and the best day to sell for highest profit from historical stock prices.
Sample Input:
	prices = [7, 1, 5, 3, 6, 4]
	Buy at 1 and sell at 6.

	45, 12, 3, 10, 50
	Best time to buy 3 best time to sell 50

	-10, -5, -2, -1, 1
	Best time to buy -10 best time to sell 1

	90, 40, 20, 10, 4
	Best time to buy 10 best time to sell 4





















generics>> CRUD, 
Array problems in loop
Array problems in recursion



















  1. Fixed Deposit (FD)
 
Maturity = Principal * (1 + (Rate / CompoundingFrequency)) ^ (CompoundingFrequency * TimeInYears)
 

- Principal = initial deposit  
- Rate = annual interest rate (decimal, e.g. 0.07 for 7%)  
- CompoundingFrequency = number of times interest is compounded per year (quarterly = 4, yearly = 1, monthly = 12)  
- TimeInYears = total duration in years  

---

  2. Recurring Deposit (RD)
 
Maturity = Installment * (( (1 + (Rate / CompoundingFrequency)) ^ (CompoundingFrequency * TimeInYears) - 1 ) / (1 - (1 + (Rate / CompoundingFrequency)) ^ (-CompoundingFrequency / 12)))
 

- Installment = monthly deposit  
- Rate = annual interest rate (decimal)  
- CompoundingFrequency = usually 4 (quarterly)  
- TimeInYears = total duration in years  

---

  3. Systematic Investment Plan (SIP)
 
Maturity = Installment * ( ((1 + MonthlyRate) ^ TotalMonths - 1) / MonthlyRate ) * (1 + MonthlyRate)
 

- Installment = monthly investment  
- MonthlyRate = annual rate / 12 (decimal)  
- TotalMonths = number of months  

---

4. Systematic Withdrawal Plan (SWP)

InitialInvestment = Withdrawal * ( (1 - (1 + MonthlyRate) ^ (-TotalMonths)) / MonthlyRate )


- Withdrawal = fixed withdrawal per month  
- MonthlyRate = annual rate / 12 (decimal)  
- TotalMonths = number of months  