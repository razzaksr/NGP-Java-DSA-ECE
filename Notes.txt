https://github.com/razzaksr/NGP-Java-DSA-ECE

Sorting algorithms:
Insertion
Merge
Selection
Quick

Searching algorithms:
Linear 
Ternary
Binary



generics>> CRUD, 
Array problems in loop
Array problems in recursion



















  1. Fixed Deposit (FD)
 
Maturity = Principal * (1 + (Rate / CompoundingFrequency)) ^ (CompoundingFrequency * TimeInYears)
 

- Principal = initial deposit  
- Rate = annual interest rate (decimal, e.g. 0.07 for 7%)  
- CompoundingFrequency = number of times interest is compounded per year (quarterly = 4, yearly = 1, monthly = 12)  
- TimeInYears = total duration in years  

---

  2. Recurring Deposit (RD)
 
Maturity = Installment * (( (1 + (Rate / CompoundingFrequency)) ^ (CompoundingFrequency * TimeInYears) - 1 ) / (1 - (1 + (Rate / CompoundingFrequency)) ^ (-CompoundingFrequency / 12)))
 

- Installment = monthly deposit  
- Rate = annual interest rate (decimal)  
- CompoundingFrequency = usually 4 (quarterly)  
- TimeInYears = total duration in years  

---

  3. Systematic Investment Plan (SIP)
 
Maturity = Installment * ( ((1 + MonthlyRate) ^ TotalMonths - 1) / MonthlyRate ) * (1 + MonthlyRate)
 

- Installment = monthly investment  
- MonthlyRate = annual rate / 12 (decimal)  
- TotalMonths = number of months  

---

4. Systematic Withdrawal Plan (SWP)

InitialInvestment = Withdrawal * ( (1 - (1 + MonthlyRate) ^ (-TotalMonths)) / MonthlyRate )


- Withdrawal = fixed withdrawal per month  
- MonthlyRate = annual rate / 12 (decimal)  
- TotalMonths = number of months  




Assessment:
1. Write a method to calculate delivery charges based on distance. Overload it for weight-based charges too

2. Write a method to calculate monthly emi based on principleAmount, roi for 3 years. Overload it for Collateral to reduce roi

3. Write a program to find second maximum in unsorted array of product prices.

4. Write a program to find and print account balances those are not maintaining minimum balance threshold from unsorted array of customer balances


5. Banking:
Account (abstract class) contains accountNumber, accountBalance with subclasses SavingsAccount and CurrentAccount.
Interface Transaction with deposit() and withdraw().
Savings Account:
withdraw >> no charges upto 50000, 3% for more than 50000
CurrentAccount:
withdraw>> charges for each 10000 of 2.5%


Discussed Setter and Getter


Storage Structures: Linear
	Array
	Stack >> LIFO
		push, pop, peek, isEmpty, viewAll
	Implementation:
		In built: java.util.Stack
		Manual Implementation:
			1. fixed memory using array
			2. dynamic memory using object oriented/ linkedlist

Collection Framework
Iterable>> Collection>> AbstractCollection>> Vector>> Stack

Validate Expression with Brackets, Parenthesis


Largest rectangle are in histogram

1, 3, 5,4,2              max=Integer.MIN_VALUE
0  1  2 3 4

index=0, arr[index] = 1>> current
push 0
Stack>> for index          
0 


Daily Temperature 
Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.
Example 1:
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
Example 2:
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]



Queue >> FiFo
	enqueue, dequeue, isEmpty, front, rear
	
	Implementation:
	1. fixed memory via stack
	2. inbuilt class>> Queue>> java.util
	3. LinkedList/ Object oriented


	Queue>>
		offer(enqueue), poll(dequeue), empty
		PriorityQueue>> Deque
			remove small element always
			if we wish removal in different way we can configure
		



Collection framework: 
to overcome array drawbacks
	List>> ArrayList, LinkedList

LinkedList >> 
	add / addLast, addaddFirst, add(pos,object)

	get(pos), getFirst, getLast

	remove / removeFirst, removeLast, remove(position)

ArrayList:
	add, add(pos,obj), addAll
	set(pos,obj)
	contains(obj)// true/false
	remove(obj)
	get(pos)





---






Command Prompt:
java   -version



environment path settings:

vs code java extension:
EXTENSION PACK FOR JAVA


FD Calculator:
oneYear  = pA * roi/100 >> single year interest

oneYear * duration


Versions of solution:
without OOP
encapsulation
polymorphsim



inheritance
overriding
upcast, downcast


Abstraction:
	Interface
	Abstract class
	Overriding
	
User defined Class as generic to Collections


Comparator interface>> 
bean class and interface implementation can be separate
	compare(Object o1,Object o2)>> override

Queue with problem solving:
	rotation
	palindrome


Comparable interface>> 
implementation has to be done in bean class itself
	compareTo(Object o) >> override


Set : 
	LinkedHashSet, HashSet, TreeSet
	TreeSet with User Defined Type
	Comparable implementation


Map: <K, V>:
Key Objects Should not be duplicated, Value Objects can be
insert>> put(k,v), putAll
read>> get(K)
check>>containsKey(K) , containsValue(V)
read only keys>> keySet()>> convert K Objects into new Set
read only values> values() >> convert V Objects into Collection
delete >> remove(K)

	HashMap/ Hashtable
	TreeMap


1. Count Occurrences of String
2. Find Distinct digits
3. Agile Kanban Board implemented via Map
4. Undirected Graph representation using Map
	

















Single Number
Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.
Example 1:
Input: nums = [2,2,1]
Output: 1

Example 2:
Input: nums = [4,1,2,1,2]
Output: 4

Example 3:
Input: nums = [1]
Output: 1



Counting Bits:
Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.

Example 1:
Input: n = 2
Output: [0,1,1]
Explanation:0 --> 0   1 --> 1         2 --> 10

Example 2:
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101


Find the least prime number within the boundary that can be added with first array element that makes them divisible by second array elements at respective index
		Input:
		int[] arr1 = {3, 5, 7};
		int[] arr2 = {10, 15, 20};
		Output:
		7 -1 13 
		Input:
		int[] arr1 = {4, 6, 8};
		int[] arr2 = {5, 10, 15};
		Output:
		-1 -1 -1

1. Move Zeroes
Problem Statement:
Rearrange a delivery queue where zeros indicate unavailable trucks; push them to the end without disrupting the rest.
	Sample Input:
	nums = [0, 1, 0, 3, 12]
	Expected Output:
	[1, 3, 12, 0, 0]

	Input:
	20,0,19,5,0,3,10,0,2
	Output:
	20,19,5,3,10,2,0,0,0

	Input:
	3,0,0,1,0,5,0,6,0
	Output:
	3,1,5,6,0,0,0,0,0




Rotate Image
You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
Example 2:
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]














Rotating clock wise and anti clock wise
example:
arr = [DBMS, OS, DSA, Network, AI]
n = 2
Clock Wise: 
[Network, AI, DBMS, OS, DSA]
Anti Clock Wise: 
[DSA, Network, AI, DBMS, OS]


Find Pivot Index
Problem Statement:
Determine the index at which the workload to its left equals the workload to its right.
	Sample Input:
	nums = [1, 7, 3, 6, 5, 6]
	Expected Output:	3
	Explanation: 1 + 7 + 3 = 11, 5 + 6 = 11.
	Input:
	-7, 1, 5, 2, -4, 3, 0
	Output:	3
	Input:
	0,-3,5,-4,-2,3,1,0
	Output:	0


Group Anagrams
		Problem Statement:
		Cluster search queries or user aliases that are scrambled versions of each other — useful in NLP or 		search optimization.
		Sample Input:
		strs = ["eat","tea","tan","ate","nat","bat"]
		Expected Output:
		[["eat","tea","ate"], ["tan","nat"], ["bat"]]



Minimum Moves to Convert String
You are given a string s consisting of n characters which are either 'X' or 'O'.
A move is defined as selecting three consecutive characters of s and converting them to 'O'. Note that if a move is applied to the character 'O', it will stay the same.
Return the minimum number of moves required so that all the characters of s are converted to 'O'.
		Example 1:
		Input: s = "XXX"
		Output: 1	
		Explanation: XXX -> OOO
		We select all the 3 characters and convert them in one move.
		Example 2:
		Input: s = "XXOX"
		Output: 2
		Explanation: XXOX -> OOOX -> OOOO
We select the first 3 characters in the first move, and convert them to 'O'.
Then we select the last 3 characters and convert them so that the final string contains all 'O's.
		Example 3:
		Input: s = "OOOO"
		Output: 0
Explanation: There are no 'X's in s to convert.










Validating IPV4
Input: s = "222.111.111.111"
Output: true
Explanation: Here, the IPv4 address is as per the criteria mentioned and also all four decimal numbers lies in the mentioned range.
Input: s = "5555..555"
Output: false
Explanation: "5555..555" is not a valid. IPv4 address, as the middle two portions are missing.
Input: s = "0.0.0.0255"
Output: false
Input: 121.433.122.111
Output: false
Input: 192.168.137.12
Output: true
Input: 22.0..123
Output: false
Input: 1.2.3.4.
Output: false
Input: .1.2.3.4
Output: false



Debt Offset Triplets
In financial reconciliation systems or crowdfunding platforms, contributions from individuals may either be positive (contributions) or negative (debts). When evaluating such data, it becomes important to identify sets of contributors whose combined impact on the overall balance nets to zero.
You are given a list of integers nums, where each value represents the contribution or debt of a participant. Your task is to find all unique triplets in the list which sum to zero.
Each triplet must include three distinct elements from the array, and the result must not contain duplicate triplets, regardless of the order. For example, triplets like [-1, 0, 1] and [0, 1, -1] are considered the same and should be reported only once.
This problem simulates scenarios such as offsetting financial imbalances, detecting fraudulent balancing acts, or automated clearing systems identifying neutralizing transactions.
Example 1:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Example 2:
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
Example 3:
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.





Trapping Rain Water
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
Example 1:
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water are being trapped.

Example 2:
Input: height = [4,2,0,3,2,5]
Output: 9




Best Time to Buy and Sell Stock
Problem Statement:
Identify the best day to buy and the best day to sell for highest profit from historical stock prices.
Sample Input:
	prices = [7, 1, 5, 3, 6, 4]
	Buy at 1 and sell at 6.

	45, 12, 3, 10, 50
	Best time to buy 3 best time to sell 50

	-10, -5, -2, -1, 1
	Best time to buy -10 best time to sell 1

	90, 40, 20, 10, 4
	Best time to buy 10 best time to sell 4

	10,6,4,8,2
	Best time to buy 4 best time to sell 8
	
	3, 2, 6, 5, 0, 3
	
	10, 8, 7, 5, 2

You are given a 0-indexed array of integers nums of length n. You are initially positioned at index 0.
Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at index i, you can jump to any index (i + j) where:
0 <= j <= nums[i] and
i + j < n
Return the minimum number of jumps to reach index n - 1. The test cases are generated such that you can reach index n - 1.

Example 1:
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:
Input: nums = [2,3,0,1,4]
Output: 2
Example 3:
Input: nums = [3,2,1,0,4],                  
Output: -1



Divide and Conquer
1. Sum of array
	a. 0 based split via new array using copyOfRange
	b. 0 based split via current and current+1 

2. find max in array using divide and conquer
input: arr = [34,12,67,32,11]
Output: 67
input: arr = [120,97,35,122]
Output: 122
	a. 0 based split
	b. mid based split

3. Climbing Stairs
Input: 3
Output: 3
Input: 5
Output: 8
Input: 4
Output: 5
Input: -2
Output: 0
Input: 1
Output: 1
Input: 2
Output: 2

Search Insert Position
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must write an algorithm with O(log n) runtime complexity.

Example 1:
Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:
Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:
Input: nums = [1,3,5,6], target = 7
Output: 4

Constraints:
1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums contains distinct values sorted in ascending order.
-104 <= target <= 104




Find Minimum in Rotated Sorted Array
Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:
[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].
Given the sorted rotated array nums of unique elements, return the minimum element of this array.
You must write an algorithm that runs in O(log n) time.

Example 1:
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
Example 2:
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
Example 3:
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 

Constraints:
n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000
All the integers of nums are unique.
nums is sorted and rotated between 1 and n times.


Valid Perfect Square
Given a positive integer num, return true if num is a perfect square or false otherwise.
A perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.
You must not use any built-in library function, such as sqrt.

Example 1:
Input: num = 16
Output: true
Explanation: We return true because 4 * 4 = 16 and 4 is an integer.
Example 2:
Input: num = 14
Output: false
Explanation: We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.

Constraints:
1 <= num <= 231 - 1



Special Array With X Elements Greater Than or Equal X
You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.
Notice that x does not have to be an element in nums.
Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.

note: if x is 2 then numbers in array greater than or equals to 2's matching count should be  exactly 2, not more / less than that

Example 1:
Input: nums = [3,5]
Output: 2
Explanation: There are 2 values (3 and 5) that are greater than or equal to 2.
Example 2:
Input: nums = [0,0]
Output: -1
Explanation: No numbers fit the criteria for x.
If x = 0, there should be 0 numbers >= x, but there are 2.
If x = 1, there should be 1 number >= x, but there are 0.
If x = 2, there should be 2 numbers >= x, but there are 0.
x cannot be greater since there are only 2 numbers in nums.
Example 3:
Input: nums = [0,4,3,0,4]
Output: 3
Explanation: There are 3 values that are greater than or equal to 3.
Example 4:
Input: nums = [3,6,7,7,0]
Output: -1

Constraints:
1 <= nums.length <= 100
0 <= nums[i] <= 1000




Cutting Ribbons
You are given an array ribbons where ribbons[i] represents the length of the i-th ribbon. You are also given an integer k.
Your task is to determine the maximum integer length L such that you can cut at least k ribbons of length L from the given ribbons.
- You may cut each ribbon into multiple smaller ribbons of length L.
- You may discard leftover pieces that are shorter than L.
- You cannot join ribbons together.
If it is not possible to cut at least k ribbons of any positive length, return 0.

Example 1
Input: ribbons = [9,7,5] , k = 3
Output: 5
Explanation:
- Cut ribbon 9 → [5,4] → one ribbon of length 5.
- Cut ribbon 7 → [5,2] → one ribbon of length 5.
- Cut ribbon 5 → [5] → one ribbon of length 5.
Total = 3 ribbons of length 5.
Example 2
Input: ribbons = [7,5,9], k = 4
Output: 4
Explanation:
- Cut ribbon 7 → [4,3] → one ribbon of length 4.
- Cut ribbon 5 → [4,1] → one ribbon of length 4.
- Cut ribbon 9 → [4,4,1] → two ribbons of length 4.
Total = 4 ribbons of length 4.
Example 3
Input: ribbons = [5,5,5], k = 4
Output: 2

Constraints
- 1 <= ribbons.length <= 10^5
- 1 <= ribbons[i] <= 10^5
- 1 <= k <= 10^9



N-th Tribonacci Number
The Tribonacci sequence Tn is defined as follows: 
T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.
Given n, return the value of Tn.
Example 1:
Input: n = 4
Output: 4
Explanation:
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
Example 2:
Input: n = 25
Output: 1389537
Constraints:
0 <= n <= 37
The answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.


Decode Ways
You have intercepted a secret message encoded as a string of numbers. The message is decoded via the following mapping:
"1" -> 'A'
"2" -> 'B'
...
"25" -> 'Y'
"26" -> 'Z'
However, while decoding the message, you realize that there are many different ways you can decode the message because some codes are contained in other codes ("2" and "5" vs "25").
For example, "11106" can be decoded into:
"AAJF" with the grouping (1, 1, 10, 6)
"KJF" with the grouping (11, 10, 6)
The grouping (1, 11, 06) is invalid because "06" is not a valid code (only "6" is valid).
Note: there may be strings that are impossible to decode.
Given a string s containing only digits, return the number of ways to decode it. If the entire string cannot be decoded in any valid way, return 0.
The test cases are generated so that the answer fits in a 32-bit integer.
Example 1:
Input: s = "12"
Output: 2
Explanation:
"12" could be decoded as "AB" (1 2) or "L" (12).
Example 2:
Input: s = "226"
Output: 3
Explanation:
"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
Example 3:
Input: s = "06"
Output: 0
Explanation:
"06" cannot be mapped to "F" because of the leading zero ("6" is different from "06"). In this case, the string is not a valid encoding, so return 0.
Constraints:
1 <= s.length <= 100
s contains only digits and may contain leading zero(s).





Coin Change
You are given an integer array  denoms representing  denoms of different denominations and an integer amount representing a total amount of money.
Return the fewest number of  denoms that you need to make up that amount. If that amount of money cannot be made up by any combination of the  denoms, return -1.
You may assume that you have an infinite number of each kind of  denom.
Input:  denoms = [100, 500, 200]  , amount = 1100
Output: 3
Input:  denoms = [100, 200, 500]  , amount = 8700
Output: 18
Input: [500,200], amount=1100
Output: 4
Input: [500,200], amount=1300
Output: 5
Input: [500,200], amount=100
Output: -1



Edit Distance
Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.
You have the following three operations permitted on a word:
Insert a character
Delete a character
Replace a character
Example 1:
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
Constraints:
0 <= word1.length, word2.length <= 500
word1 and word2 consist of lowercase English letters.


Minimum Path Sum
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Example 1:
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
Example 2:
Input: grid = [[1,2,3],[4,5,6]]
Output: 12
Constraints:
m == grid.length
n == grid[i].length
1 <= m, n <= 200
0 <= grid[i][j] <= 200

