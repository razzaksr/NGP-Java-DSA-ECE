https://github.com/razzaksr/NGP-Java-DSA-ECE

Sorting algorithms:
Insertion
Merge
Selection
Quick

Searching algorithms:
Linear 
Ternary
Binary




Assessment:
1. Write a method to calculate delivery charges based on distance. Overload it for weight-based charges too

2. Write a method to calculate monthly emi based on principleAmount, roi for 3 years. Overload it for Collateral to reduce roi

3. Write a program to find second maximum in unsorted array of product prices.

4. Write a program to find and print account balances those are not maintaining minimum balance threshold from unsorted array of customer balances


5. Banking:
Account (abstract class) contains accountNumber, accountBalance with subclasses SavingsAccount and CurrentAccount.
Interface Transaction with deposit() and withdraw().
Savings Account:
withdraw >> no charges upto 50000, 3% for more than 50000
CurrentAccount:
withdraw>> charges for each 10000 of 2.5%


Discussed Setter and Getter


Storage Structures: Linear
	Array
	Stack >> LIFO
		push, pop, peek, isEmpty, viewAll
	Implementation:
		In built: java.util.Stack
		Manual Implementation:
			1. fixed memory using array
			2. dynamic memory using object oriented/ linkedlist

Collection Framework
Iterable>> Collection>> AbstractCollection>> Vector>> Stack

Validate Expression with Brackets, Parenthesis


Largest rectangle are in histogram

1, 3, 5,4,2              max=Integer.MIN_VALUE
0  1  2 3 4

index=0, arr[index] = 1>> current
push 0
Stack>> for index          
0 


Daily Temperature 
Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.
Example 1:
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
Example 2:
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]



Queue >> FiFo
	enqueue, dequeue, isEmpty, front, rear
	
	Implementation:
	1. fixed memory via stack
	2. inbuilt class>> Queue>> java.util
	3. LinkedList/ Object oriented


	Queue>>
		offer(enqueue), poll(dequeue), empty
		PriorityQueue>> Deque
			remove small element always
			if we wish removal in different way we can configure
		



Collection framework: 
to overcome array drawbacks
	List>> ArrayList, LinkedList

LinkedList >> 
	add / addLast, addaddFirst, add(pos,object)

	get(pos), getFirst, getLast

	remove / removeFirst, removeLast, remove(position)

ArrayList:
	add, add(pos,obj), addAll
	set(pos,obj)
	contains(obj)// true/false
	remove(obj)
	get(pos)





---






Command Prompt:
java   -version



environment path settings:

vs code java extension:
EXTENSION PACK FOR JAVA


FD Calculator:
oneYear  = pA * roi/100 >> single year interest

oneYear * duration


Versions of solution:
without OOP
encapsulation
polymorphsim



inheritance
overriding
upcast, downcast


Abstraction:
	Interface
	Abstract class
	Overriding
	
User defined Class as generic to Collections


Comparator interface>> 
bean class and interface implementation can be separate
	compare(Object o1,Object o2)>> override

Queue with problem solving:
	rotation
	palindrome


Comparable interface>> 
implementation has to be done in bean class itself
	compareTo(Object o) >> override


Set : 
	LinkedHashSet, HashSet, TreeSet
	TreeSet with User Defined Type
	Comparable implementation


Map: <K, V>:
Key Objects Should not be duplicated, Value Objects can be
insert>> put(k,v), putAll
read>> get(K)
check>>containsKey(K) , containsValue(V)
read only keys>> keySet()>> convert K Objects into new Set
read only values> values() >> convert V Objects into Collection
delete >> remove(K)

	HashMap/ Hashtable
	TreeMap


1. Count Occurrences of String
2. Find Distinct digits
3. Agile Kanban Board implemented via Map
4. Undirected Graph representation using Map
	

















generics>> CRUD, 
Array problems in loop
Array problems in recursion



















  1. Fixed Deposit (FD)
 
Maturity = Principal * (1 + (Rate / CompoundingFrequency)) ^ (CompoundingFrequency * TimeInYears)
 

- Principal = initial deposit  
- Rate = annual interest rate (decimal, e.g. 0.07 for 7%)  
- CompoundingFrequency = number of times interest is compounded per year (quarterly = 4, yearly = 1, monthly = 12)  
- TimeInYears = total duration in years  

---

  2. Recurring Deposit (RD)
 
Maturity = Installment * (( (1 + (Rate / CompoundingFrequency)) ^ (CompoundingFrequency * TimeInYears) - 1 ) / (1 - (1 + (Rate / CompoundingFrequency)) ^ (-CompoundingFrequency / 12)))
 

- Installment = monthly deposit  
- Rate = annual interest rate (decimal)  
- CompoundingFrequency = usually 4 (quarterly)  
- TimeInYears = total duration in years  

---

  3. Systematic Investment Plan (SIP)
 
Maturity = Installment * ( ((1 + MonthlyRate) ^ TotalMonths - 1) / MonthlyRate ) * (1 + MonthlyRate)
 

- Installment = monthly investment  
- MonthlyRate = annual rate / 12 (decimal)  
- TotalMonths = number of months  

---

4. Systematic Withdrawal Plan (SWP)

InitialInvestment = Withdrawal * ( (1 - (1 + MonthlyRate) ^ (-TotalMonths)) / MonthlyRate )


- Withdrawal = fixed withdrawal per month  
- MonthlyRate = annual rate / 12 (decimal)  
- TotalMonths = number of months  